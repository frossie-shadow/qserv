/*
 * LSST Data Management System
 * Copyright 2011-2017 LSST Corporation.
 *
 * This product includes software developed by the
 * LSST Project (http://www.lsst.org/).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the LSST License Statement and
 * the GNU General Public License along with this program.  If not,
 * see <http://www.lsstcorp.org/LegalNotices/>.
 */
/// replication.proto
/// This defines the wire-messages sent between replication master and workers.

package lsst.qserv.proto;

//////////////////////////////////////////////////////////////////////
// Replication header sent to a worker. Any communication begins with
// sending this header and specifying a type of the request.
//
// Chunk replication requests must be followed by another message of
// the corresponding type to provide a scope of the request.
//
// Requests affecting the overall status of the service do not require
// any additional messages.

// Request types related to operations with replicas
//
enum ReplicationReplicaRequestType {

    REPLICA_CREATE   = 0;    // replicate a chunk
    REPLICA_DELETE   = 1;    // delete an existing replica of a chunk
    REPLICA_FIND     = 2;    // find out if a replica is present, and report its state
    REPLICA_FIND_ALL = 3;    // find all replicas and report their states
}

// Request types for managing above defined requests
//
enum ReplicationManagementRequestType {

    REQUEST_STATUS   = 0;    // check a status of a request
    REQUEST_STOP     = 1;    // stop a previously requested request
}

// Request types affecting the overall state of the worker replication service
//
enum ReplicationServiceRequestType {

    SERVICE_SUSPEND  = 0;
    SERVICE_RESUME   = 1;
    SERVICE_STATUS   = 2;
    SERVICE_REQUESTS = 3;  // get info on all replication related requests known
                           // to the service
}

// Message header is sent next after the frame size request. A sender must
// indicate a class of a request by choosing one of a few options defined
// in 'Type', and then set the specific request in the corresponding
// optional field.
//
message ReplicationRequestHeader {

    enum RequestType {
        REPLICA = 0;
        REQUEST = 1;
        SERVICE = 2;
    }
    
    // The request type selector determines which class of the below specified
    // optional subtypes to use

    required RequestType type = 1;

    // Subtypes of requests

    optional ReplicationReplicaRequestType    replica_type    = 2;
    optional ReplicationManagementRequestType management_type = 3;
    optional ReplicationServiceRequestType    service_type    = 4;
}

//
// The type of the next message (if any) to be sent depends on  specific type of
// the operation. It should provide additional parameters of the operation.
//

// This is a replication request. The message defines a scope of the request and
// its unique identity. This message is sent once after the header.
//
message ReplicationRequestReplicate {
    required string id       = 1;
    required int32  priority = 2;
    required string database = 3;
    required uint32 chunk    = 4;
    required string worker   = 5;
}

// This is a replica deletion request. The message defines a scope of the request
// and its unique identity. This message is sent once after the header.
//
message ReplicationRequestDelete {
    required string id       = 1;
    required int32  priority = 2;
    required string database = 3;
    required uint32 chunk    = 4;
}

// This is a replica lookup request. The message defines a scope of the request
// and its unique identity. This message is sent once after the header.
//
message ReplicationRequestFind {
    required string id       = 1;
    required int32  priority = 2;
    required string database = 3;
    required uint32 chunk    = 4;
}

// This is a replica lookup request for multiple replicas. The message defines
// a scope of the request and its unique identity. This message is sent once
// after the header.
//
message ReplicationRequestFindAll {
    required string id       = 1;
    required int32  priority = 2;
    required string database = 3;
}

// This request is sent to stop an on-going replication (if any is still in progress).
// This message is sent once after the header.
//
message ReplicationRequestStop {

    required string id = 1;    // an identifier of a request to be stopped

    // A specific type of the request will affect a choice
    // of the status object returned in response

    required ReplicationReplicaRequestType type = 2;
}

// This request is sent to request a status of an on-going replication (if any
// is still in progress). This message is sent once after the header.
//
message ReplicationRequestStatus {

    required string id = 1;    // an identifier of a request to be inspected

    // A specific type of the request will affect a choice
    // of the status object returned in response

    required ReplicationReplicaRequestType type = 2;
}

//
// These messages are expected by master upon a completion of
// the corresponding replication operations.
//

// Status values returned by all request related to operations with
// replicas. Request management operations always return messages whose types
// match the return types of the corresponding (original) replica-related reqiests.
// Service management requests have their own set of status values.
//
enum ReplicationStatus {
    SUCCESS       = 0;
    QUEUED        = 1;
    IN_PROGRESS   = 2;
    IS_CANCELLING = 3;
    BAD           = 4;
    FAILED        = 5;
    CANCELLED     = 6;
}

message ReplicationReplicaCreateInfo {
    required float progress = 1;
}
message ReplicationResponseReplicate {
    required ReplicationStatus status = 1;
    optional ReplicationReplicaCreateInfo replication_info = 2;
}

message ReplicationReplicaDeleteInfo {
    required float progress = 1;
}
message ReplicationResponseDelete {
    required ReplicationStatus status = 1;
    optional ReplicationReplicaDeleteInfo delete_info = 2;
}

message ReplicationReplicaInfo {
    enum ReplicaStatus {
        NOT_FOUND  = 0;
        CORRUPT    = 1;
        INCOMPLETE = 2;
        COMPLETE   = 3;
    }
    required ReplicaStatus status   = 1;
    required string        worker   = 2;
    required string        database = 3;
    required uint32        chunk    = 4;
}

message ReplicationResponseFind {
    required ReplicationStatus      status = 1;
    optional ReplicationReplicaInfo replica_info = 2;
}

message ReplicationResponseFindAll {
    required ReplicationStatus      status = 1;
    repeated ReplicationReplicaInfo replica_info_many = 2;
}

/////////////////////////////////////////////////////////////////////////
// The message returned in response to requests related to (or affecting)
// the overall state of the server-side replication service.

message ReplicationServiceRequestInfo {

    // Replication related requests only

    required ReplicationReplicaRequestType replica_type = 1;

    // Common parameters of all requests

    required string id       = 2;
    required int32  priority = 3;
    required string database = 4;
 
    // These parameters vary depending on a request type

    optional uint32 chunk    = 5;
    optional string worker   = 6;
}

message ReplicationServiceResponse {

    // Completion status of the operation
    
    enum Status {
        SUCCESS = 0;
        FAILED  = 1;
    }
    required Status status = 1;

    enum ServiceState {
        SUSPEND_IN_PROGRESS = 0;
        SUSPENDED           = 1;
        RUNNING             = 2;
    }
    required ServiceState service_state = 2;

    // Counters for requests known to the service since its last start

    required uint32 num_new_requests         = 3;
    required uint32 num_in_progress_requests = 4;
    required uint32 num_finished_requests    = 5;

    // Optional (depending on a request) collections of requests in each queue
    
    repeated ReplicationServiceRequestInfo new_requests         = 6;
    repeated ReplicationServiceRequestInfo in_progress_requests = 7;
    repeated ReplicationServiceRequestInfo finished_requests    = 8;
}